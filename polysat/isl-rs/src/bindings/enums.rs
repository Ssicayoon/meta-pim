// Automatically generated by isl_bindings_generator.
// LICENSE: MIT

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ArgType {
    End,
    Alias,
    Arg,
    Bool,
    Child,
    Choice,
    Flags,
    Footer,
    Int,
    User,
    Long,
    Ulong,
    Str,
    StrList,
    Version,
}

impl ArgType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ArgType::End => 0,
            ArgType::Alias => 1,
            ArgType::Arg => 2,
            ArgType::Bool => 3,
            ArgType::Child => 4,
            ArgType::Choice => 5,
            ArgType::Flags => 6,
            ArgType::Footer => 7,
            ArgType::Int => 8,
            ArgType::User => 9,
            ArgType::Long => 10,
            ArgType::Ulong => 11,
            ArgType::Str => 12,
            ArgType::StrList => 13,
            ArgType::Version => 14,
        }
    }
}

impl ArgType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            0 => ArgType::End,
            1 => ArgType::Alias,
            2 => ArgType::Arg,
            3 => ArgType::Bool,
            4 => ArgType::Child,
            5 => ArgType::Choice,
            6 => ArgType::Flags,
            7 => ArgType::Footer,
            8 => ArgType::Int,
            9 => ArgType::User,
            10 => ArgType::Long,
            11 => ArgType::Ulong,
            12 => ArgType::Str,
            13 => ArgType::StrList,
            14 => ArgType::Version,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ASTExprOpType {
    Error,
    And,
    AndThen,
    Or,
    OrElse,
    Max,
    Min,
    Minus,
    Add,
    Sub,
    Mul,
    Div,
    FdivQ,
    PdivQ,
    PdivR,
    ZdivR,
    Cond,
    Select,
    Eq,
    Le,
    Lt,
    Ge,
    Gt,
    Call,
    Access,
    Member,
    AddressOf,
}

impl ASTExprOpType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ASTExprOpType::Error => -1,
            ASTExprOpType::And => 0,
            ASTExprOpType::AndThen => 1,
            ASTExprOpType::Or => 2,
            ASTExprOpType::OrElse => 3,
            ASTExprOpType::Max => 4,
            ASTExprOpType::Min => 5,
            ASTExprOpType::Minus => 6,
            ASTExprOpType::Add => 7,
            ASTExprOpType::Sub => 8,
            ASTExprOpType::Mul => 9,
            ASTExprOpType::Div => 10,
            ASTExprOpType::FdivQ => 11,
            ASTExprOpType::PdivQ => 12,
            ASTExprOpType::PdivR => 13,
            ASTExprOpType::ZdivR => 14,
            ASTExprOpType::Cond => 15,
            ASTExprOpType::Select => 16,
            ASTExprOpType::Eq => 17,
            ASTExprOpType::Le => 18,
            ASTExprOpType::Lt => 19,
            ASTExprOpType::Ge => 20,
            ASTExprOpType::Gt => 21,
            ASTExprOpType::Call => 22,
            ASTExprOpType::Access => 23,
            ASTExprOpType::Member => 24,
            ASTExprOpType::AddressOf => 25,
        }
    }
}

impl ASTExprOpType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => ASTExprOpType::Error,
            0 => ASTExprOpType::And,
            1 => ASTExprOpType::AndThen,
            2 => ASTExprOpType::Or,
            3 => ASTExprOpType::OrElse,
            4 => ASTExprOpType::Max,
            5 => ASTExprOpType::Min,
            6 => ASTExprOpType::Minus,
            7 => ASTExprOpType::Add,
            8 => ASTExprOpType::Sub,
            9 => ASTExprOpType::Mul,
            10 => ASTExprOpType::Div,
            11 => ASTExprOpType::FdivQ,
            12 => ASTExprOpType::PdivQ,
            13 => ASTExprOpType::PdivR,
            14 => ASTExprOpType::ZdivR,
            15 => ASTExprOpType::Cond,
            16 => ASTExprOpType::Select,
            17 => ASTExprOpType::Eq,
            18 => ASTExprOpType::Le,
            19 => ASTExprOpType::Lt,
            20 => ASTExprOpType::Ge,
            21 => ASTExprOpType::Gt,
            22 => ASTExprOpType::Call,
            23 => ASTExprOpType::Access,
            24 => ASTExprOpType::Member,
            25 => ASTExprOpType::AddressOf,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ASTExprType {
    Error,
    Op,
    Id,
    Int,
}

impl ASTExprType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ASTExprType::Error => -1,
            ASTExprType::Op => 0,
            ASTExprType::Id => 1,
            ASTExprType::Int => 2,
        }
    }
}

impl ASTExprType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => ASTExprType::Error,
            0 => ASTExprType::Op,
            1 => ASTExprType::Id,
            2 => ASTExprType::Int,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ASTLoopType {
    Error,
    Default,
    Atomic,
    Unroll,
    Separate,
}

impl ASTLoopType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ASTLoopType::Error => -1,
            ASTLoopType::Default => 0,
            ASTLoopType::Atomic => 1,
            ASTLoopType::Unroll => 2,
            ASTLoopType::Separate => 3,
        }
    }
}

impl ASTLoopType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => ASTLoopType::Error,
            0 => ASTLoopType::Default,
            1 => ASTLoopType::Atomic,
            2 => ASTLoopType::Unroll,
            3 => ASTLoopType::Separate,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ASTNodeType {
    Error,
    For,
    If,
    Block,
    Mark,
    User,
}

impl ASTNodeType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ASTNodeType::Error => -1,
            ASTNodeType::For => 0,
            ASTNodeType::If => 1,
            ASTNodeType::Block => 2,
            ASTNodeType::Mark => 3,
            ASTNodeType::User => 4,
        }
    }
}

impl ASTNodeType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => ASTNodeType::Error,
            0 => ASTNodeType::For,
            1 => ASTNodeType::If,
            2 => ASTNodeType::Block,
            3 => ASTNodeType::Mark,
            4 => ASTNodeType::User,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DimType {
    Cst,
    Param,
    In,
    Out,
    Set,
    Div,
    All,
}

impl DimType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            DimType::Cst => 0,
            DimType::Param => 1,
            DimType::In => 2,
            DimType::Out => 3,
            DimType::Set => 3,
            DimType::Div => 4,
            DimType::All => 5,
        }
    }
}

impl DimType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            0 => DimType::Cst,
            1 => DimType::Param,
            2 => DimType::In,
            3 => DimType::Out,
            3 => DimType::Set,
            4 => DimType::Div,
            5 => DimType::All,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Error {
    None,
    Abort,
    Alloc,
    Unknown,
    Internal,
    Invalid,
    Quota,
    Unsupported,
}

impl Error {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            Error::None => 0,
            Error::Abort => 1,
            Error::Alloc => 2,
            Error::Unknown => 3,
            Error::Internal => 4,
            Error::Invalid => 5,
            Error::Quota => 6,
            Error::Unsupported => 7,
        }
    }
}

impl Error {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            0 => Error::None,
            1 => Error::Abort,
            2 => Error::Alloc,
            3 => Error::Unknown,
            4 => Error::Internal,
            5 => Error::Invalid,
            6 => Error::Quota,
            7 => Error::Unsupported,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Fold {
    Error,
    Min,
    Max,
    List,
}

impl Fold {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            Fold::Error => -1,
            Fold::Min => 0,
            Fold::Max => 1,
            Fold::List => 2,
        }
    }
}

impl Fold {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => Fold::Error,
            0 => Fold::Min,
            1 => Fold::Max,
            2 => Fold::List,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ScheduleNodeType {
    Error,
    Band,
    Context,
    Domain,
    Expansion,
    Extension,
    Filter,
    Leaf,
    Guard,
    Mark,
    Sequence,
    Set,
}

impl ScheduleNodeType {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            ScheduleNodeType::Error => -1,
            ScheduleNodeType::Band => 0,
            ScheduleNodeType::Context => 1,
            ScheduleNodeType::Domain => 2,
            ScheduleNodeType::Expansion => 3,
            ScheduleNodeType::Extension => 4,
            ScheduleNodeType::Filter => 5,
            ScheduleNodeType::Leaf => 6,
            ScheduleNodeType::Guard => 7,
            ScheduleNodeType::Mark => 8,
            ScheduleNodeType::Sequence => 9,
            ScheduleNodeType::Set => 10,
        }
    }
}

impl ScheduleNodeType {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => ScheduleNodeType::Error,
            0 => ScheduleNodeType::Band,
            1 => ScheduleNodeType::Context,
            2 => ScheduleNodeType::Domain,
            3 => ScheduleNodeType::Expansion,
            4 => ScheduleNodeType::Extension,
            5 => ScheduleNodeType::Filter,
            6 => ScheduleNodeType::Leaf,
            7 => ScheduleNodeType::Guard,
            8 => ScheduleNodeType::Mark,
            9 => ScheduleNodeType::Sequence,
            10 => ScheduleNodeType::Set,
            _ => panic!("Illegal value."),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Stat {
    Error,
    Ok,
}

impl Stat {
    /// Returns i32 values as defined in libisl.
    pub fn to_i32(&self) -> i32 {
        match self {
            Stat::Error => -1,
            Stat::Ok => 0,
        }
    }
}

impl Stat {
    /// Constructor based on the i32 values as defined in libisl.
    pub fn from_i32(val: i32) -> Self {
        match val {
            -1 => Stat::Error,
            0 => Stat::Ok,
            _ => panic!("Illegal value."),
        }
    }
}
