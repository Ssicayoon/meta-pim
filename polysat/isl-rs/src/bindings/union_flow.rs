// Automatically generated by isl_bindings_generator.
// LICENSE: MIT

use super::{Context, UnionMap};
use libc::uintptr_t;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Wraps `isl_union_flow`.
pub struct UnionFlow {
    pub ptr: uintptr_t,
    pub should_free_on_drop: bool,
}

extern "C" {

    fn isl_union_flow_copy(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_free(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_ctx(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_full_may_dependence(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_full_must_dependence(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_may_dependence(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_may_no_source(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_must_dependence(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_get_must_no_source(flow: uintptr_t) -> uintptr_t;

    fn isl_union_flow_to_str(flow: uintptr_t) -> *const c_char;

}

impl UnionFlow {
    /// Wraps `isl_union_flow_copy`.
    pub fn copy(&self) -> UnionFlow {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_copy(flow) };
        let isl_rs_result = UnionFlow { ptr: isl_rs_result,
                                        should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_free`.
    pub fn free(self) -> UnionFlow {
        let flow = self;
        let mut flow = flow;
        flow.do_not_free_on_drop();
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_free(flow) };
        let isl_rs_result = UnionFlow { ptr: isl_rs_result,
                                        should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_ctx`.
    pub fn get_ctx(&self) -> Context {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_ctx(flow) };
        let isl_rs_result = Context { ptr: isl_rs_result,
                                      should_free_on_drop: false };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_full_may_dependence`.
    pub fn get_full_may_dependence(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_full_may_dependence(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_full_must_dependence`.
    pub fn get_full_must_dependence(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_full_must_dependence(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_may_dependence`.
    pub fn get_may_dependence(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_may_dependence(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_may_no_source`.
    pub fn get_may_no_source(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_may_no_source(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_must_dependence`.
    pub fn get_must_dependence(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_must_dependence(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_get_must_no_source`.
    pub fn get_must_no_source(&self) -> UnionMap {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_get_must_no_source(flow) };
        let isl_rs_result = UnionMap { ptr: isl_rs_result,
                                       should_free_on_drop: true };
        isl_rs_result
    }

    /// Wraps `isl_union_flow_to_str`.
    pub fn to_str(&self) -> &str {
        let flow = self;
        let flow = flow.ptr;
        let isl_rs_result = unsafe { isl_union_flow_to_str(flow) };
        let isl_rs_result = unsafe { CStr::from_ptr(isl_rs_result) };
        let isl_rs_result = isl_rs_result.to_str().unwrap();
        isl_rs_result
    }

    /// Does not call isl_union_flow_free() on being dropped. (For internal use
    /// only.)
    pub fn do_not_free_on_drop(&mut self) {
        self.should_free_on_drop = false;
    }
}

impl Drop for UnionFlow {
    fn drop(&mut self) {
        if self.should_free_on_drop {
            unsafe {
                isl_union_flow_free(self.ptr);
            }
        }
    }
}
