// Automatically generated by isl_bindings_generator.
// LICENSE: MIT

use super::{
    ASTLoopType, Context, Id, MultiUnionPwAff, MultiVal, Schedule, ScheduleNodeType, ScheduleTree,
    Set, Space, UnionMap, UnionPwMultiAff, UnionSet, UnionSetList,
};
use libc::uintptr_t;
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

/// Wraps `isl_schedule_node`.
pub struct ScheduleNode {
    pub ptr: uintptr_t,
    pub should_free_on_drop: bool,
}

extern "C" {

    fn isl_schedule_node_align_params(node: uintptr_t, space: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_ancestor(node: uintptr_t, generation: i32) -> uintptr_t;

    fn isl_schedule_node_band_get_ast_build_options(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_get_ast_isolate_option(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_get_partial_schedule(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_get_partial_schedule_union_map(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_get_permutable(node: uintptr_t) -> i32;

    fn isl_schedule_node_band_get_space(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_member_get_ast_loop_type(node: uintptr_t, pos: i32) -> i32;

    fn isl_schedule_node_band_member_get_coincident(node: uintptr_t, pos: i32) -> i32;

    fn isl_schedule_node_band_member_get_isolate_ast_loop_type(node: uintptr_t, pos: i32) -> i32;

    fn isl_schedule_node_band_member_set_ast_loop_type(
        node: uintptr_t, pos: i32, type_: i32,
    ) -> uintptr_t;

    fn isl_schedule_node_band_member_set_coincident(
        node: uintptr_t, pos: i32, coincident: i32,
    ) -> uintptr_t;

    fn isl_schedule_node_band_member_set_isolate_ast_loop_type(
        node: uintptr_t, pos: i32, type_: i32,
    ) -> uintptr_t;

    fn isl_schedule_node_band_mod(node: uintptr_t, mv: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_n_member(node: uintptr_t) -> i32;

    fn isl_schedule_node_band_scale(node: uintptr_t, mv: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_scale_down(node: uintptr_t, mv: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_set_ast_build_options(
        node: uintptr_t, options: uintptr_t,
    ) -> uintptr_t;

    fn isl_schedule_node_band_set_permutable(node: uintptr_t, permutable: i32) -> uintptr_t;

    fn isl_schedule_node_band_shift(node: uintptr_t, shift: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_sink(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_band_split(node: uintptr_t, pos: i32) -> uintptr_t;

    fn isl_schedule_node_band_tile(node: uintptr_t, sizes: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_child(node: uintptr_t, pos: i32) -> uintptr_t;

    fn isl_schedule_node_context_get_context(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_copy(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_cut(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_delete(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_domain_get_domain(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_dump(node: uintptr_t) -> ();

    fn isl_schedule_node_expansion_get_contraction(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_expansion_get_expansion(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_extension_get_extension(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_filter_get_filter(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_first_child(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_free(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_from_domain(domain: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_from_extension(extension: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_ancestor_child_position(node: uintptr_t, ancestor: uintptr_t) -> i32;

    fn isl_schedule_node_get_child(node: uintptr_t, pos: i32) -> uintptr_t;

    fn isl_schedule_node_get_child_position(node: uintptr_t) -> i32;

    fn isl_schedule_node_get_ctx(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_domain(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_parent_type(node: uintptr_t) -> i32;

    fn isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_prefix_schedule_relation(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_prefix_schedule_union_map(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_schedule(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_schedule_depth(node: uintptr_t) -> i32;

    fn isl_schedule_node_get_shared_ancestor(node1: uintptr_t, node2: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_subtree_contraction(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_subtree_expansion(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_subtree_schedule_union_map(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_get_tree_depth(node: uintptr_t) -> i32;

    fn isl_schedule_node_get_type(node: uintptr_t) -> i32;

    fn isl_schedule_node_get_universe_domain(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_graft_after(node: uintptr_t, graft: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_graft_before(node: uintptr_t, graft: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_grandchild(node: uintptr_t, pos1: i32, pos2: i32) -> uintptr_t;

    fn isl_schedule_node_grandparent(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_group(node: uintptr_t, group_id: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_guard_get_guard(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_has_children(node: uintptr_t) -> i32;

    fn isl_schedule_node_has_next_sibling(node: uintptr_t) -> i32;

    fn isl_schedule_node_has_parent(node: uintptr_t) -> i32;

    fn isl_schedule_node_has_previous_sibling(node: uintptr_t) -> i32;

    fn isl_schedule_node_insert_context(node: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_insert_filter(node: uintptr_t, filter: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_insert_guard(node: uintptr_t, context: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_insert_mark(node: uintptr_t, mark: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_insert_partial_schedule(node: uintptr_t, schedule: uintptr_t)
        -> uintptr_t;

    fn isl_schedule_node_insert_sequence(node: uintptr_t, filters: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_insert_set(node: uintptr_t, filters: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_is_equal(node1: uintptr_t, node2: uintptr_t) -> i32;

    fn isl_schedule_node_is_subtree_anchored(node: uintptr_t) -> i32;

    fn isl_schedule_node_mark_get_id(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_n_children(node: uintptr_t) -> i32;

    fn isl_schedule_node_next_sibling(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_order_after(node: uintptr_t, filter: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_order_before(node: uintptr_t, filter: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_parent(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_previous_sibling(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_reset_user(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_root(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_sequence_splice_child(node: uintptr_t, pos: i32) -> uintptr_t;

    fn isl_schedule_node_sequence_splice_children(node: uintptr_t) -> uintptr_t;

    fn isl_schedule_node_to_str(node: uintptr_t) -> *const c_char;

    // ðŸ†• Private ISL APIs for tree-level manipulation
    // These are declared in isl_schedule_node_private.h but exported in the library
    // Used to implement band_set_partial_schedule via tree operations

    /// Gets the schedule tree at this node position (from private API)
    /// Returns: __isl_give isl_schedule_tree *
    fn isl_schedule_node_get_tree(node: uintptr_t) -> uintptr_t;

    /// Grafts a schedule tree at this node position (from private API)
    /// Takes ownership of both node and tree
    /// Returns: __isl_give isl_schedule_node *
    fn isl_schedule_node_graft_tree(node: uintptr_t, tree: uintptr_t) -> uintptr_t;

}

impl ScheduleNode {
    /// Wraps `isl_schedule_node_align_params`.
    pub fn align_params(self, space: Space) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut space = space;
        space.do_not_free_on_drop();
        let space = space.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_align_params(node, space) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_ancestor`.
    pub fn ancestor(self, generation: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_ancestor(node, generation) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_ast_build_options`.
    pub fn band_get_ast_build_options(&self) -> UnionSet {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_ast_build_options(node) };
        let isl_rs_result = UnionSet {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_ast_isolate_option`.
    pub fn band_get_ast_isolate_option(&self) -> Set {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_ast_isolate_option(node) };
        let isl_rs_result = Set {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_partial_schedule`.
    pub fn band_get_partial_schedule(&self) -> MultiUnionPwAff {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_partial_schedule(node) };
        let isl_rs_result = MultiUnionPwAff {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_partial_schedule_union_map`.
    pub fn band_get_partial_schedule_union_map(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_partial_schedule_union_map(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_permutable`.
    pub fn band_get_permutable(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_permutable(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_get_space`.
    pub fn band_get_space(&self) -> Space {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_get_space(node) };
        let isl_rs_result = Space {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_get_ast_loop_type`.
    pub fn band_member_get_ast_loop_type(&self, pos: i32) -> ASTLoopType {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_member_get_ast_loop_type(node, pos) };
        let isl_rs_result = ASTLoopType::from_i32(isl_rs_result);
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_get_coincident`.
    pub fn band_member_get_coincident(&self, pos: i32) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_member_get_coincident(node, pos) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_get_isolate_ast_loop_type`.
    pub fn band_member_get_isolate_ast_loop_type(&self, pos: i32) -> ASTLoopType {
        let node = self;
        let node = node.ptr;
        let isl_rs_result =
            unsafe { isl_schedule_node_band_member_get_isolate_ast_loop_type(node, pos) };
        let isl_rs_result = ASTLoopType::from_i32(isl_rs_result);
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_set_ast_loop_type`.
    pub fn band_member_set_ast_loop_type(self, pos: i32, type_: ASTLoopType) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let type_ = type_.to_i32();
        let isl_rs_result =
            unsafe { isl_schedule_node_band_member_set_ast_loop_type(node, pos, type_) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_set_coincident`.
    pub fn band_member_set_coincident(self, pos: i32, coincident: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result =
            unsafe { isl_schedule_node_band_member_set_coincident(node, pos, coincident) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_member_set_isolate_ast_loop_type`.
    pub fn band_member_set_isolate_ast_loop_type(
        self, pos: i32, type_: ASTLoopType,
    ) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let type_ = type_.to_i32();
        let isl_rs_result =
            unsafe { isl_schedule_node_band_member_set_isolate_ast_loop_type(node, pos, type_) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_mod`.
    pub fn band_mod(self, mv: MultiVal) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut mv = mv;
        mv.do_not_free_on_drop();
        let mv = mv.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_mod(node, mv) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_n_member`.
    pub fn band_n_member(&self) -> i32 {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_n_member(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_scale`.
    pub fn band_scale(self, mv: MultiVal) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut mv = mv;
        mv.do_not_free_on_drop();
        let mv = mv.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_scale(node, mv) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_scale_down`.
    pub fn band_scale_down(self, mv: MultiVal) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut mv = mv;
        mv.do_not_free_on_drop();
        let mv = mv.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_scale_down(node, mv) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_set_ast_build_options`.
    pub fn band_set_ast_build_options(self, options: UnionSet) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut options = options;
        options.do_not_free_on_drop();
        let options = options.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_set_ast_build_options(node, options) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_set_permutable`.
    pub fn band_set_permutable(self, permutable: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_set_permutable(node, permutable) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_shift`.
    pub fn band_shift(self, shift: MultiUnionPwAff) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut shift = shift;
        shift.do_not_free_on_drop();
        let shift = shift.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_shift(node, shift) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_sink`.
    pub fn band_sink(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_sink(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_split`.
    pub fn band_split(self, pos: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_split(node, pos) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_band_tile`.
    pub fn band_tile(self, sizes: MultiVal) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut sizes = sizes;
        sizes.do_not_free_on_drop();
        let sizes = sizes.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_band_tile(node, sizes) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_child`.
    pub fn child(self, pos: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_child(node, pos) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_context_get_context`.
    pub fn context_get_context(&self) -> Set {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_context_get_context(node) };
        let isl_rs_result = Set {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_copy`.
    pub fn copy(&self) -> ScheduleNode {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_copy(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_cut`.
    pub fn cut(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_cut(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_delete`.
    pub fn delete(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_delete(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_domain_get_domain`.
    pub fn domain_get_domain(&self) -> UnionSet {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_domain_get_domain(node) };
        let isl_rs_result = UnionSet {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_dump`.
    pub fn dump(&self) -> () {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_dump(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_expansion_get_contraction`.
    pub fn expansion_get_contraction(&self) -> UnionPwMultiAff {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_expansion_get_contraction(node) };
        let isl_rs_result = UnionPwMultiAff {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_expansion_get_expansion`.
    pub fn expansion_get_expansion(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_expansion_get_expansion(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_extension_get_extension`.
    pub fn extension_get_extension(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_extension_get_extension(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_filter_get_filter`.
    pub fn filter_get_filter(&self) -> UnionSet {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_filter_get_filter(node) };
        let isl_rs_result = UnionSet {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_first_child`.
    pub fn first_child(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_first_child(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_free`.
    pub fn free(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_free(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_from_domain`.
    pub fn from_domain(domain: UnionSet) -> ScheduleNode {
        let mut domain = domain;
        domain.do_not_free_on_drop();
        let domain = domain.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_from_domain(domain) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_from_extension`.
    pub fn from_extension(extension: UnionMap) -> ScheduleNode {
        let mut extension = extension;
        extension.do_not_free_on_drop();
        let extension = extension.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_from_extension(extension) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_ancestor_child_position`.
    pub fn get_ancestor_child_position(&self, ancestor: &ScheduleNode) -> i32 {
        let node = self;
        let node = node.ptr;
        let ancestor = ancestor.ptr;
        let isl_rs_result =
            unsafe { isl_schedule_node_get_ancestor_child_position(node, ancestor) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_child`.
    pub fn get_child(&self, pos: i32) -> ScheduleNode {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_child(node, pos) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_child_position`.
    pub fn get_child_position(&self) -> i32 {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_child_position(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_ctx`.
    pub fn get_ctx(&self) -> Context {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_ctx(node) };
        let isl_rs_result = Context {
            ptr: isl_rs_result,
            should_free_on_drop: false,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_domain`.
    pub fn get_domain(&self) -> UnionSet {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_domain(node) };
        let isl_rs_result = UnionSet {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_parent_type`.
    pub fn get_parent_type(&self) -> ScheduleNodeType {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_parent_type(node) };
        let isl_rs_result = ScheduleNodeType::from_i32(isl_rs_result);
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_prefix_schedule_multi_union_pw_aff`.
    pub fn get_prefix_schedule_multi_union_pw_aff(&self) -> MultiUnionPwAff {
        let node = self;
        let node = node.ptr;
        let isl_rs_result =
            unsafe { isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(node) };
        let isl_rs_result = MultiUnionPwAff {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_prefix_schedule_relation`.
    pub fn get_prefix_schedule_relation(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_prefix_schedule_relation(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_prefix_schedule_union_map`.
    pub fn get_prefix_schedule_union_map(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_prefix_schedule_union_map(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_prefix_schedule_union_pw_multi_aff`.
    pub fn get_prefix_schedule_union_pw_multi_aff(&self) -> UnionPwMultiAff {
        let node = self;
        let node = node.ptr;
        let isl_rs_result =
            unsafe { isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(node) };
        let isl_rs_result = UnionPwMultiAff {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_schedule`.
    pub fn get_schedule(&self) -> Schedule {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_schedule(node) };
        let isl_rs_result = Schedule {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_schedule_depth`.
    pub fn get_schedule_depth(&self) -> i32 {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_schedule_depth(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_shared_ancestor`.
    pub fn get_shared_ancestor(&self, node2: &ScheduleNode) -> ScheduleNode {
        let node1 = self;
        let node1 = node1.ptr;
        let node2 = node2.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_shared_ancestor(node1, node2) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_subtree_contraction`.
    pub fn get_subtree_contraction(&self) -> UnionPwMultiAff {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_subtree_contraction(node) };
        let isl_rs_result = UnionPwMultiAff {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_subtree_expansion`.
    pub fn get_subtree_expansion(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_subtree_expansion(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_subtree_schedule_union_map`.
    pub fn get_subtree_schedule_union_map(&self) -> UnionMap {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_subtree_schedule_union_map(node) };
        let isl_rs_result = UnionMap {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_tree_depth`.
    pub fn get_tree_depth(&self) -> i32 {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_tree_depth(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_type`.
    pub fn get_type(&self) -> ScheduleNodeType {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_type(node) };
        let isl_rs_result = ScheduleNodeType::from_i32(isl_rs_result);
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_get_universe_domain`.
    pub fn get_universe_domain(&self) -> UnionSet {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_get_universe_domain(node) };
        let isl_rs_result = UnionSet {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_graft_after`.
    pub fn graft_after(self, graft: ScheduleNode) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut graft = graft;
        graft.do_not_free_on_drop();
        let graft = graft.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_graft_after(node, graft) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_graft_before`.
    pub fn graft_before(self, graft: ScheduleNode) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut graft = graft;
        graft.do_not_free_on_drop();
        let graft = graft.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_graft_before(node, graft) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_grandchild`.
    pub fn grandchild(self, pos1: i32, pos2: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_grandchild(node, pos1, pos2) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_grandparent`.
    pub fn grandparent(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_grandparent(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_group`.
    pub fn group(self, group_id: Id) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut group_id = group_id;
        group_id.do_not_free_on_drop();
        let group_id = group_id.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_group(node, group_id) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_guard_get_guard`.
    pub fn guard_get_guard(&self) -> Set {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_guard_get_guard(node) };
        let isl_rs_result = Set {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_has_children`.
    pub fn has_children(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_has_children(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_has_next_sibling`.
    pub fn has_next_sibling(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_has_next_sibling(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_has_parent`.
    pub fn has_parent(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_has_parent(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_has_previous_sibling`.
    pub fn has_previous_sibling(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_has_previous_sibling(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_context`.
    pub fn insert_context(self, context: Set) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_context(node, context) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_filter`.
    pub fn insert_filter(self, filter: UnionSet) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut filter = filter;
        filter.do_not_free_on_drop();
        let filter = filter.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_filter(node, filter) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_guard`.
    pub fn insert_guard(self, context: Set) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut context = context;
        context.do_not_free_on_drop();
        let context = context.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_guard(node, context) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_mark`.
    pub fn insert_mark(self, mark: Id) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut mark = mark;
        mark.do_not_free_on_drop();
        let mark = mark.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_mark(node, mark) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_partial_schedule`.
    pub fn insert_partial_schedule(self, schedule: MultiUnionPwAff) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut schedule = schedule;
        schedule.do_not_free_on_drop();
        let schedule = schedule.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_partial_schedule(node, schedule) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_sequence`.
    pub fn insert_sequence(self, filters: UnionSetList) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut filters = filters;
        filters.do_not_free_on_drop();
        let filters = filters.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_sequence(node, filters) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_insert_set`.
    pub fn insert_set(self, filters: UnionSetList) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut filters = filters;
        filters.do_not_free_on_drop();
        let filters = filters.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_insert_set(node, filters) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_is_equal`.
    pub fn is_equal(&self, node2: &ScheduleNode) -> bool {
        let node1 = self;
        let node1 = node1.ptr;
        let node2 = node2.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_is_equal(node1, node2) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_is_subtree_anchored`.
    pub fn is_subtree_anchored(&self) -> bool {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_is_subtree_anchored(node) };
        let isl_rs_result = match isl_rs_result {
            0 => false,
            1 => true,
            _ => panic!("Got isl_bool = -1"),
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_mark_get_id`.
    pub fn mark_get_id(&self) -> Id {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_mark_get_id(node) };
        let isl_rs_result = Id {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_n_children`.
    pub fn n_children(&self) -> i32 {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_n_children(node) };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_next_sibling`.
    pub fn next_sibling(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_next_sibling(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_order_after`.
    pub fn order_after(self, filter: UnionSet) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut filter = filter;
        filter.do_not_free_on_drop();
        let filter = filter.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_order_after(node, filter) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_order_before`.
    pub fn order_before(self, filter: UnionSet) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let mut filter = filter;
        filter.do_not_free_on_drop();
        let filter = filter.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_order_before(node, filter) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_parent`.
    pub fn parent(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_parent(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_previous_sibling`.
    pub fn previous_sibling(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_previous_sibling(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_reset_user`.
    pub fn reset_user(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_reset_user(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_root`.
    pub fn root(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_root(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_sequence_splice_child`.
    pub fn sequence_splice_child(self, pos: i32) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_sequence_splice_child(node, pos) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_sequence_splice_children`.
    pub fn sequence_splice_children(self) -> ScheduleNode {
        let node = self;
        let mut node = node;
        node.do_not_free_on_drop();
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_sequence_splice_children(node) };
        let isl_rs_result = ScheduleNode {
            ptr: isl_rs_result,
            should_free_on_drop: true,
        };
        isl_rs_result
    }

    /// Wraps `isl_schedule_node_to_str`.
    pub fn to_str(&self) -> &str {
        let node = self;
        let node = node.ptr;
        let isl_rs_result = unsafe { isl_schedule_node_to_str(node) };
        let isl_rs_result = unsafe { CStr::from_ptr(isl_rs_result) };
        let isl_rs_result = isl_rs_result.to_str().unwrap();
        isl_rs_result
    }

    // ========================================================================
    // ðŸ†• Helper Methods for Loop Transformations
    // ========================================================================

    /// Swaps coincident flags for two dimensions after loop interchange.
    ///
    /// # Purpose
    ///
    /// When you interchange two loop dimensions using `band_set_partial_schedule`,
    /// **the coincident flags do NOT automatically update**. This helper method
    /// synchronizes the flags after dimension permutation.
    ///
    /// **Why this is necessary**:
    /// - ISL stores coincident flags separately from the partial schedule
    /// - When you swap dimensions in the schedule, flags remain at original positions
    /// - Mismatched flags can cause:
    ///   - Incorrect parallelization decisions
    ///   - Lost optimization opportunities
    ///   - Code generation bugs
    ///
    /// # When to Use
    ///
    /// **Always use this after 2D loop interchange**:
    /// ```ignore
    /// // Step 1: Interchange dimensions in schedule
    /// let partial = band_node.band_get_partial_schedule();
    /// let dim_i = partial.get_at(0);
    /// let dim_j = partial.get_at(1);
    /// let new_partial = partial.set_at(0, dim_j).set_at(1, dim_i);
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    ///
    /// // Step 2: Synchronize coincident flags (CRITICAL)
    /// let new_node = new_node.swap_coincident_flags(0, 1);
    /// ```
    ///
    /// **For 3+ dimensions**, use `permute_coincident_flags()` instead.
    ///
    /// # Arguments
    ///
    /// - `dim1`: First dimension index (0-based, must be < `band_n_member()`)
    /// - `dim2`: Second dimension index (0-based, must be < `band_n_member()`)
    ///
    /// Dimensions can be in any order: `swap(0, 1)` â‰¡ `swap(1, 0)`
    ///
    /// # Examples
    ///
    /// ## Basic 2D Interchange
    /// ```ignore
    /// // Original: for i, for j (i is parallel, j is not)
    /// band_node = band_node.band_member_set_coincident(0, 1); // i: parallel
    /// band_node = band_node.band_member_set_coincident(1, 0); // j: sequential
    ///
    /// // Interchange i â†” j
    /// let partial = band_node.band_get_partial_schedule();
    /// let new_partial = partial.set_at(0, partial.get_at(1))
    ///                          .set_at(1, partial.get_at(0));
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    ///
    /// // Now: for j, for i (order swapped, but flags still at old positions!)
    /// // âŒ Without swap: new_node.band_member_get_coincident(0) == true (WRONG! j is not parallel)
    /// // âœ… With swap:
    /// let new_node = new_node.swap_coincident_flags(0, 1);
    /// assert_eq!(new_node.band_member_get_coincident(0), false); // j: sequential
    /// assert_eq!(new_node.band_member_get_coincident(1), true);  // i: parallel
    /// ```
    ///
    /// ## GEMM Partial Interchange
    /// ```ignore
    /// // Original: for i, for j, for k
    /// // Interchange only i â†” j (keep k unchanged)
    /// let partial = band_node.band_get_partial_schedule();
    /// let new_partial = partial
    ///     .set_at(0, partial.get_at(1))
    ///     .set_at(1, partial.get_at(0))
    ///     .set_at(2, partial.get_at(2)); // k unchanged
    ///
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    /// let new_node = new_node.swap_coincident_flags(0, 1); // Sync i â†” j flags only
    /// ```
    ///
    /// # Relationship to Other Functions
    ///
    /// | Function | Use Case |
    /// |----------|----------|
    /// | `swap_coincident_flags(i, j)` | 2D interchange (i â†” j) |
    /// | `permute_coincident_flags(&perm)` | N-D permutation ([i,j,k] â†’ [k,i,j]) |
    /// | `band_member_set_coincident(i, flag)` | Manual flag setting (avoid if possible) |
    /// | `band_set_partial_schedule(sched)` | The transformation that requires flag sync |
    ///
    /// # Implementation Details
    ///
    /// ```ignore
    /// // Atomically swaps flags at two positions:
    /// let flag_1 = self.band_member_get_coincident(dim1);
    /// let flag_2 = self.band_member_get_coincident(dim2);
    /// self.band_member_set_coincident(dim1, flag_2)
    ///     .band_member_set_coincident(dim2, flag_1)
    /// ```
    ///
    /// # Panics
    ///
    /// - `dim1 >= band_n_member()` or `dim2 >= band_n_member()`: Dimension out of bounds
    /// - Node is not a band node: `get_type() != ScheduleNodeType::Band`
    ///
    /// # Performance
    ///
    /// **O(1)** - Two flag reads + two flag writes
    ///
    /// # See Also
    ///
    /// - `permute_coincident_flags()`: For general N-D permutations
    /// - `band_set_partial_schedule()`: The transformation requiring flag sync
    /// - Tests: `tests/test_band_transformation.rs::test_interchange_with_coincident_flags`
    pub fn swap_coincident_flags(self, dim1: i32, dim2: i32) -> ScheduleNode {
        // Get current coincident flags for both dimensions
        let coincident_1 = self.band_member_get_coincident(dim1);
        let coincident_2 = self.band_member_get_coincident(dim2);

        // Convert bool to i32 for ISL API
        let coincident_1_i32 = if coincident_1 { 1 } else { 0 };
        let coincident_2_i32 = if coincident_2 { 1 } else { 0 };

        // Swap: set dim1 to old dim2's flag, set dim2 to old dim1's flag
        let node = self.band_member_set_coincident(dim1, coincident_2_i32);
        let node = node.band_member_set_coincident(dim2, coincident_1_i32);

        node
    }

    /// Applies arbitrary permutation to coincident flags for N-dimensional loop reordering.
    ///
    /// # Purpose
    ///
    /// When permuting more than 2 loop dimensions (e.g., `[i,j,k] â†’ [k,i,j]`),
    /// you need to reorder the coincident flags to match. This method generalizes
    /// `swap_coincident_flags()` to handle any permutation.
    ///
    /// **Why this is necessary**:
    /// - Same reason as `swap_coincident_flags()`: flags don't auto-update
    /// - For N>2 dimensions, manual swapping becomes error-prone
    /// - This method applies the permutation atomically and correctly
    ///
    /// # When to Use
    ///
    /// **Use for any non-trivial dimension reordering**:
    /// - `[i,j,k] â†’ [k,i,j]` (rotation)
    /// - `[i,j,k] â†’ [j,k,i]` (rotation)
    /// - `[i,j,k] â†’ [k,j,i]` (reverse)
    /// - `[i,j,k,l] â†’ [l,i,k,j]` (complex permutation)
    ///
    /// **For simple 2D swap, prefer `swap_coincident_flags()`**:
    /// - `[i,j] â†’ [j,i]`: Use `swap_coincident_flags(0, 1)` (simpler)
    /// - (WARN) `[i,j] â†’ [j,i]`: Can use `permute_coincident_flags(&[1, 0])` (overkill)
    ///
    /// # Arguments
    ///
    /// - `permutation`: Array mapping **new position â†’ old position**
    ///
    /// **Permutation Semantics**:
    /// ```ignore
    /// permutation = [2, 0, 1]
    /// â†“
    /// new_dimension[0] = old_dimension[2]  // new[0] â† old[2]
    /// new_dimension[1] = old_dimension[0]  // new[1] â† old[0]
    /// new_dimension[2] = old_dimension[1]  // new[2] â† old[1]
    /// ```
    ///
    /// **Constraints**:
    /// - `permutation.len() == band_n_member()` (must cover all dimensions)
    /// - All indices in `[0, n_members)` (no duplicates, no gaps)
    /// - Valid permutations are bijections: `Ïƒ: {0..n-1} â†’ {0..n-1}`
    ///
    /// # Examples
    ///
    /// ## GEMM Loop Rotation: [i,j,k] â†’ [k,i,j]
    /// ```ignore
    /// // Original schedule: for i, for j, for k
    /// // Original flags: [true, false, true] (i parallel, j sequential, k parallel)
    ///
    /// // Step 1: Permute partial schedule
    /// let partial = band_node.band_get_partial_schedule();
    /// let new_partial = partial
    ///     .set_at(0, partial.get_at(2))  // new[0] = k
    ///     .set_at(1, partial.get_at(0))  // new[1] = i
    ///     .set_at(2, partial.get_at(1)); // new[2] = j
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    ///
    /// // Step 2: Permute flags using same mapping
    /// let new_node = new_node.permute_coincident_flags(&[2, 0, 1]);
    /// //                                                   â†‘  â†‘  â†‘
    /// //                                       new[0]â†old[2], new[1]â†old[0], new[2]â†old[1]
    ///
    /// // Result: for k, for i, for j
    /// // Result flags: [true, true, false] (k parallel, i parallel, j sequential)
    /// assert_eq!(new_node.band_member_get_coincident(0), true);  // k (was at pos 2)
    /// assert_eq!(new_node.band_member_get_coincident(1), true);  // i (was at pos 0)
    /// assert_eq!(new_node.band_member_get_coincident(2), false); // j (was at pos 1)
    /// ```
    ///
    /// ## NTT Reverse: [i,j,k] â†’ [k,j,i]
    /// ```ignore
    /// // Reverse first and last dimensions
    /// let partial = band_node.band_get_partial_schedule();
    /// let new_partial = partial
    ///     .set_at(0, partial.get_at(2))  // new[0] = k
    ///     .set_at(1, partial.get_at(1))  // new[1] = j (unchanged)
    ///     .set_at(2, partial.get_at(0)); // new[2] = i
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    /// let new_node = new_node.permute_coincident_flags(&[2, 1, 0]);
    /// ```
    ///
    /// ## 4D Tensor Transpose: [n,c,h,w] â†’ [n,h,w,c]
    /// ```ignore
    /// // Move channel dimension to end
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    /// let new_node = new_node.permute_coincident_flags(&[0, 2, 3, 1]);
    /// //                                                  â†‘  â†‘  â†‘  â†‘
    /// //                                         n stays, câ†’end, hâ†’pos1, wâ†’pos2
    /// ```
    ///
    /// # Derivation: How to Construct Permutation Array
    ///
    /// **Method 1: Track dimension sources**
    /// ```ignore
    /// Original: [i, j, k]  â†’  Target: [k, i, j]
    ///
    /// Ask for each new position: "Where did this dimension come from?"
    /// new[0] = k  â† old[2]  â†’  permutation[0] = 2
    /// new[1] = i  â† old[0]  â†’  permutation[1] = 0
    /// new[2] = j  â† old[1]  â†’  permutation[2] = 1
    ///
    /// Result: permutation = [2, 0, 1]
    /// ```
    ///
    /// **Method 2: Use same permutation as partial schedule**
    /// ```ignore
    /// partial.set_at(0, partial.get_at(2))  â†’  perm[0] = 2
    /// partial.set_at(1, partial.get_at(0))  â†’  perm[1] = 0
    /// partial.set_at(2, partial.get_at(1))  â†’  perm[2] = 1
    /// ```
    ///
    /// # Common Pitfalls
    ///
    /// | Mistake | Symptom | Fix |
    /// |---------|---------|-----|
    /// | Permutation length mismatch | Panic: "length must equal band dimension" | Ensure `perm.len() == band_n_member()` |
    /// | Index out of bounds | Panic: "index N out of bounds" | All indices must be in `[0, n_members)` |
    /// | Duplicate indices | Silent correctness bug | Permutation must be bijective |
    /// | Inverted mapping | Flags end up wrong | Use newâ†’old mapping, not oldâ†’new |
    /// | Forgot to call after transformation | Wrong parallelization | Always pair with `band_set_partial_schedule()` |
    ///
    /// # Implementation Details
    ///
    /// ```ignore
    /// // 1. Read all current flags into array
    /// current_flags = [flag[0], flag[1], ..., flag[n-1]]
    ///
    /// // 2. Apply permutation: new[i] = old[permutation[i]]
    /// for i in 0..n_members:
    ///     self.band_member_set_coincident(i, current_flags[permutation[i]])
    /// ```
    ///
    /// # Panics
    ///
    /// - `permutation.len() != band_n_member()`: Length mismatch
    /// - `permutation[i] >= n_members`: Index out of bounds for any `i`
    /// - Node is not a band node: `get_type() != ScheduleNodeType::Band`
    ///
    /// # Performance
    ///
    /// **O(n)** where n = `band_n_member()`
    /// - n flag reads
    /// - n flag writes
    ///
    /// # See Also
    ///
    /// - `swap_coincident_flags(i, j)`: Optimized version for 2D interchange
    /// - `band_set_partial_schedule()`: The transformation requiring flag sync
    /// - Tests: `tests/test_band_transformation.rs::test_full_permutation`
    pub fn permute_coincident_flags(self, permutation: &[usize]) -> ScheduleNode {
        let n_members = self.band_n_member() as usize;

        if permutation.len() != n_members {
            panic!(
                "Permutation length ({}) must equal band dimension ({})",
                permutation.len(),
                n_members
            );
        }

        // Collect current coincident flags
        let mut current_flags = Vec::with_capacity(n_members);
        for i in 0..n_members {
            let flag = self.band_member_get_coincident(i as i32);
            current_flags.push(if flag { 1 } else { 0 });
        }

        // Apply permutation: new[i] = old[permutation[i]]
        let mut node = self;
        for i in 0..n_members {
            let old_idx = permutation[i];
            if old_idx >= n_members {
                panic!(
                    "Permutation index {} out of bounds (n_members = {})",
                    old_idx, n_members
                );
            }
            node = node.band_member_set_coincident(i as i32, current_flags[old_idx]);
        }

        node
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ðŸ†• Tree-level operations for band partial schedule modification
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /// **ðŸ”§ Low-Level API**: Extracts the schedule tree at this node position.
    ///
    /// # âš ï¸ Warning: Most Users Should NOT Use This Directly
    ///
    /// **Prefer `band_set_partial_schedule()` instead**, which handles the full
    /// get-modify-graft cycle automatically with proper error checking.
    ///
    /// ## When You SHOULD Use This
    ///
    /// Only use `get_tree()` + `graft_tree()` manually if you need to:
    /// - Perform multiple tree-level operations before grafting back
    /// - Access tree-level APIs not exposed at node level
    /// - Implement custom tree transformations beyond partial schedule modification
    ///
    /// ## When You Should NOT Use This
    ///
    /// âŒ **For simple loop transformations** (interchange, skew, permutation)
    ///    â†’ Use `band_set_partial_schedule()` instead
    ///
    /// âŒ **Just to modify partial schedule**
    ///    â†’ Use `band_set_partial_schedule()` instead
    ///
    /// âŒ **Without understanding ISL memory management**
    ///    â†’ Use `band_set_partial_schedule()` instead
    ///
    /// # What This Function Does
    ///
    /// Extracts the `isl_schedule_tree` object at the current node position.
    /// This tree can be modified using tree-level ISL APIs, then grafted back
    /// using `graft_tree()`.
    ///
    /// **Internal implementation of `band_set_partial_schedule()`**:
    /// ```ignore
    /// pub fn band_set_partial_schedule(self, schedule: MultiUnionPwAff) -> ScheduleNode {
    ///     let tree = self.get_tree();                              // â† This function
    ///     let new_tree = tree.band_set_partial_schedule(schedule); // Tree-level API
    ///     self.graft_tree(new_tree)                                // Graft back
    /// }
    /// ```
    ///
    /// # Private API Notice
    ///
    /// This wraps `isl_schedule_node_get_tree`, which is:
    /// - **Not in public ISL headers** (`schedule_node.h`)
    /// - **Exported by ISL library** (compiled and available)
    /// - **Stable and widely used** (PPCG, Pluto rely on it)
    /// - **Only way** to implement `band_set_partial_schedule`
    ///
    /// See module-level documentation for full private API justification.
    ///
    /// # Memory Management
    ///
    /// - Returns a new `ScheduleTree` with ownership transferred to Rust
    /// - The original node remains valid and unchanged
    /// - Tree will be freed when dropped (unless grafted back)
    ///
    /// # Example: Manual Tree Modification
    ///
    /// ```ignore
    /// // âš ï¸ Advanced usage - prefer band_set_partial_schedule() for this!
    /// let tree = band_node.get_tree();
    ///
    /// // Modify at tree level
    /// let partial = tree.band_get_partial_schedule();
    /// let new_partial = /* ... permute dimensions ... */;
    /// let new_tree = tree.band_set_partial_schedule(new_partial);
    ///
    /// // Graft back
    /// let new_node = band_node.graft_tree(new_tree);
    ///
    /// // ðŸ‘ Better: Just use the high-level API
    /// let new_node = band_node.band_set_partial_schedule(new_partial);
    /// ```
    ///
    /// # Panics
    ///
    /// - ISL internal errors (rare, indicates corrupted schedule tree)
    ///
    /// # See Also
    ///
    /// - **`band_set_partial_schedule()`**: High-level API (recommended)
    /// - **`graft_tree()`**: Companion function to graft modified tree back
    /// - **`ScheduleTree`**: The returned tree type with tree-level operations
    pub fn get_tree(&self) -> ScheduleTree {
        let tree_ptr = unsafe { isl_schedule_node_get_tree(self.ptr) };
        ScheduleTree::from_ptr(tree_ptr)
    }

    /// **ðŸ”§ Low-Level API**: Grafts a modified schedule tree back at this node position.
    ///
    /// # âš ï¸ Warning: Most Users Should NOT Use This Directly
    ///
    /// **Prefer `band_set_partial_schedule()` instead**, which handles the full
    /// get-modify-graft cycle automatically with proper ownership management.
    ///
    /// ## When You SHOULD Use This
    ///
    /// Only use `get_tree()` + `graft_tree()` manually if you need to:
    /// - Apply multiple tree transformations atomically
    /// - Use tree-level ISL APIs beyond `band_set_partial_schedule`
    /// - Implement complex tree restructuring operations
    ///
    /// ## When You Should NOT Use This
    ///
    /// âŒ **For simple partial schedule modifications**
    ///    â†’ Use `band_set_partial_schedule()` instead
    ///
    /// âŒ **Without a tree from `get_tree()`**
    ///    â†’ Arbitrary trees may violate schedule invariants
    ///
    /// âŒ **Without understanding ownership semantics**
    ///    â†’ Misuse leads to double-free or use-after-free
    ///
    /// # What This Function Does
    ///
    /// Replaces the schedule tree at the current node position with the provided tree.
    /// This is the inverse operation of `get_tree()`:
    ///
    /// ```ignore
    /// let tree = node.get_tree();        // Extract
    /// let new_tree = modify(tree);       // Modify
    /// let new_node = node.graft_tree(new_tree); // â† Graft back
    /// ```
    ///
    /// **Internal implementation of `band_set_partial_schedule()`**:
    /// ```ignore
    /// pub fn band_set_partial_schedule(self, schedule: MultiUnionPwAff) -> ScheduleNode {
    ///     let tree = self.get_tree();                              // Extract
    ///     let new_tree = tree.band_set_partial_schedule(schedule); // Modify
    ///     self.graft_tree(new_tree)                                // â† This function
    /// }
    /// ```
    ///
    /// # Private API Notice
    ///
    /// This wraps `isl_schedule_node_graft_tree`, which is:
    /// - **Not in public ISL headers** (`schedule_node.h`)
    /// - **Exported by ISL library** (compiled and available)
    /// - **Stable and widely used** (PPCG, Pluto rely on it)
    /// - **Only way** to implement `band_set_partial_schedule`
    ///
    /// See module-level documentation for full private API justification.
    ///
    /// # Memory Management
    ///
    /// **This function uses move semantics**:
    /// - **Consumes `self`** (the original node) - no longer usable after call
    /// - **Consumes `tree`** (the tree to graft) - ownership transferred to ISL
    /// - **Returns new `ScheduleNode`** with the grafted tree
    ///
    /// **Ownership flow**:
    /// ```ignore
    /// let node: ScheduleNode = /* ... */;
    /// let tree: ScheduleTree = node.get_tree();
    /// let new_tree: ScheduleTree = modify(tree);
    ///
    /// let new_node = node.graft_tree(new_tree);
    /// // âŒ node is consumed (can't use anymore)
    /// // âŒ new_tree is consumed (can't use anymore)
    /// // âœ… new_node owns the result
    /// ```
    ///
    /// **Internal memory transfer**:
    /// 1. `node.do_not_free_on_drop()` - Transfer node ownership to ISL
    /// 2. `tree.do_not_free_on_drop()` - Transfer tree ownership to ISL
    /// 3. ISL manages memory and returns new node pointer
    /// 4. New `ScheduleNode` owns result (freed on drop)
    ///
    /// # Example: Multi-Operation Tree Modification
    ///
    /// ```ignore
    /// // Advanced use case: Apply multiple tree-level transformations
    /// let tree = band_node.get_tree();
    ///
    /// // Modify partial schedule
    /// let partial = tree.band_get_partial_schedule();
    /// let new_partial = /* ... permute ... */;
    /// let tree = tree.band_set_partial_schedule(new_partial);
    ///
    /// // Also modify coincident flags at tree level
    /// let tree = tree.band_member_set_coincident(0, 1);
    /// let tree = tree.band_member_set_coincident(1, 0);
    ///
    /// // Graft everything back atomically
    /// let new_node = band_node.graft_tree(tree);
    ///
    /// // ðŸ‘ Better for simple cases: Use high-level API
    /// let new_node = band_node.band_set_partial_schedule(new_partial)
    ///                         .swap_coincident_flags(0, 1);
    /// ```
    ///
    /// # Correctness Requirements
    ///
    /// The grafted tree must be **compatible** with the schedule:
    /// - âœ… Tree from `get_tree()` on same node (after modifications)
    /// - âœ… Tree with same node type (band â†’ band, filter â†’ filter)
    /// - âŒ Tree from different schedule (undefined behavior)
    /// - âŒ Tree with incompatible structure (may crash or produce invalid schedule)
    ///
    /// **ISL does NOT validate compatibility** - this is caller's responsibility.
    ///
    /// # Panics
    ///
    /// - ISL internal errors (rare, indicates corrupted tree or incompatible graft)
    ///
    /// # Performance
    ///
    /// **O(1)** - Pointer reassignment in schedule tree structure
    ///
    /// # See Also
    ///
    /// - **`band_set_partial_schedule()`**: High-level API (recommended)
    /// - **`get_tree()`**: Companion function to extract tree before modification
    /// - **`ScheduleTree`**: The tree type with tree-level operations
    pub fn graft_tree(self, tree: ScheduleTree) -> ScheduleNode {
        let mut node = self;
        node.do_not_free_on_drop(); // Transfer ownership to ISL
        let node_ptr = node.ptr;

        let mut tree = tree;
        tree.do_not_free_on_drop(); // Transfer ownership to ISL
        let tree_ptr = tree.ptr;

        let result_ptr = unsafe { isl_schedule_node_graft_tree(node_ptr, tree_ptr) };

        ScheduleNode {
            ptr: result_ptr,
            should_free_on_drop: true,
        }
    }

    /// High-level API for modifying a band node's partial schedule.
    ///
    /// This is the **recommended and correct** way to implement loop transformations like
    /// interchange, skewing, and arbitrary permutations on polyhedral schedules.
    ///
    /// # Why This API Exists
    ///
    /// ISL's C API does **not** provide `isl_schedule_node_band_set_partial_schedule`.
    /// The only way to modify a band's partial schedule is through the tree-level API:
    /// - `isl_schedule_tree_band_set_partial_schedule` (exists in ISL)
    ///
    /// This function bridges the gap by:
    /// 1. Extracting the tree from the node
    /// 2. Calling the tree-level setter
    /// 3. Grafting the modified tree back
    ///
    /// **Alternative approaches and why they fail**:
    /// - âŒ `delete() + insert_partial_schedule()`: Loses children nodes and metadata
    /// - âŒ Direct node-level FFI: Function doesn't exist in ISL
    /// - âœ… This approach: Preserves full schedule tree structure
    ///
    /// # Implementation Details
    ///
    /// Internal call chain:
    /// ```text
    /// band_set_partial_schedule(schedule)
    ///   â”œâ”€> get_tree()           // isl_schedule_node_get_tree (private API)
    ///   â”œâ”€> tree.band_set_...    // isl_schedule_tree_band_set_partial_schedule
    ///   â””â”€> graft_tree(new_tree) // isl_schedule_node_graft_tree (private API)
    /// ```
    ///
    /// **About Private APIs**: The functions `isl_schedule_node_get_tree` and
    /// `isl_schedule_node_graft_tree` are in ISL's private headers but are:
    /// - Compiled into the library and exported
    /// - Used by mature tools (PPCG, Pluto)
    /// - Stable and unlikely to change
    /// - The **only correct way** to implement this operation
    ///
    /// # Guarantees
    ///
    /// This function **guarantees** to preserve:
    /// - **Children nodes** (nested bands, filters, marks, etc.)
    /// - **Domain/filter nodes** in the schedule tree
    /// - **Tree structure integrity**
    /// - **Memory safety** (no leaks, proper ownership transfer)
    ///
    /// **Verified by tests**:
    /// - `test_children_preservation`: Nested band scenario (tile + point loops)
    /// - `test_gemm_3d_interchange`: Real GEMM workload
    ///
    /// # Critical Usage Constraints
    ///
    /// ## 1. Coincident Flags MUST Be Synchronized Manually
    ///
    /// This function does **NOT** automatically permute coincident flags when you
    /// reorder dimensions. You **MUST** call the flag synchronization helpers:
    ///
    /// ```ignore
    /// // WRONG: Flags become inconsistent
    /// let new_node = band.band_set_partial_schedule(interchanged_partial);
    ///
    /// // CORRECT: Flags synchronized with dimension order
    /// let new_node = band.band_set_partial_schedule(interchanged_partial)
    ///                    .swap_coincident_flags(0, 1);
    /// ```
    ///
    /// **Why manual sync is required**:
    /// - ISL's tree-level API doesn't know about dimension permutation semantics
    /// - Flags describe parallelism of **logical** dimensions, not physical order
    /// - User knows the transformation, so user controls flag updates
    ///
    /// ## 2. Dimension Count Must Match
    ///
    /// The new partial schedule must have the **same number of dimensions** as the
    /// current band:
    ///
    /// ```ignore
    /// let n_members = band.band_n_member();
    /// let new_partial = ...; // Must have size() == n_members
    /// ```
    ///
    /// **ISL will abort** if dimensions don't match. Always verify before calling.
    ///
    /// ## 3. Space/Domain Compatibility
    ///
    /// The new partial schedule's space must be compatible with the band's domain.
    /// ISL performs this check internally and will **abort on mismatch**.
    ///
    /// ## 4. Node Must Be a Band
    ///
    /// Only call this on band nodes. Check with:
    /// ```ignore
    /// assert_eq!(node.get_type(), ScheduleNodeType::Band);
    /// ```
    ///
    /// # Memory Management
    ///
    /// - **Consumes** both `self` and `schedule` (takes ownership)
    /// - **Returns** a new ScheduleNode (owned by caller)
    /// - ISL manages refcounts internally
    /// - Rust manages `should_free_on_drop` flags
    /// - **No memory leaks** (verified by tests)
    ///
    /// # Typical Transformation Workflow
    ///
    /// ## Loop Interchange (2D)
    ///
    /// ```ignore
    /// let band = schedule.get_root().child(0);
    ///
    /// // 1. Get current partial schedule
    /// let partial = band.band_get_partial_schedule();
    ///
    /// // 2. Extract dimensions
    /// let dim_i = partial.get_at(0);
    /// let dim_j = partial.get_at(1);
    ///
    /// // 3. Swap dimensions (i <-> j)
    /// let new_partial = partial.set_at(0, dim_j).set_at(1, dim_i);
    ///
    /// // 4. Apply transformation
    /// let new_band = band.band_set_partial_schedule(new_partial);
    ///
    /// // 5. CRITICAL: Swap coincident flags
    /// let new_band = new_band.swap_coincident_flags(0, 1);
    ///
    /// // 6. Get the modified schedule
    /// let new_schedule = new_band.get_schedule();
    /// ```
    ///
    /// ## Loop Permutation (3D: [i,j,k] -> [k,i,j])
    ///
    /// ```ignore
    /// let partial = band.band_get_partial_schedule();
    /// let dim_i = partial.get_at(0);
    /// let dim_j = partial.get_at(1);
    /// let dim_k = partial.get_at(2);
    ///
    /// // Permute to [k, i, j]
    /// let new_partial = partial
    ///     .set_at(0, dim_k)
    ///     .set_at(1, dim_i)
    ///     .set_at(2, dim_j);
    ///
    /// let new_band = band.band_set_partial_schedule(new_partial);
    ///
    /// // Permute flags: new[i] = old[perm[i]]
    /// // perm = [2, 0, 1] means new[0]=old[2], new[1]=old[0], new[2]=old[1]
    /// let new_band = new_band.permute_coincident_flags(&[2, 0, 1]);
    /// ```
    ///
    /// # Common Pitfalls and How to Avoid
    ///
    /// | Pitfall | Symptom | Solution |
    /// |---------|---------|----------|
    /// | Forgot flag sync | Incorrect parallelization | Always call swap/permute_coincident_flags |
    /// | Dimension mismatch | ISL abort | Verify partial.size() == band.band_n_member() |
    /// | Wrong node type | ISL abort | Check node.get_type() == Band |
    /// | Lost children | Nested loops broken | Use this API (not delete+insert) |
    ///
    /// # Performance
    ///
    /// - **Time**: O(1) pointer operations + O(n) for dimension manipulation
    /// - **Space**: O(1) additional memory (tree nodes are refcounted)
    /// - **Overhead**: Negligible compared to schedule construction
    ///
    /// # Related Functions
    ///
    /// - `band_get_partial_schedule()`: Get current partial schedule
    /// - `swap_coincident_flags()`: Swap two flags (for 2D interchange)
    /// - `permute_coincident_flags()`: Permute all flags (for general permutation)
    /// - `get_tree()`: Low-level tree extraction (avoid unless necessary)
    /// - `graft_tree()`: Low-level tree grafting (avoid unless necessary)
    ///
    /// # See Also
    ///
    /// - Test: `test_basic_interchange` - Simple 2D example
    /// - Test: `test_children_preservation` - Nested band scenario
    /// - Test: `test_gemm_3d_interchange` - Real GEMM workload
    pub fn band_set_partial_schedule(self, schedule: MultiUnionPwAff) -> ScheduleNode {
        // Get the tree at this node
        let tree = self.get_tree();

        // Set the new partial schedule on the tree
        let new_tree = tree.band_set_partial_schedule(schedule);

        // Note: We consumed self in get_tree(), so we need to reconstruct the node
        // Actually, get_tree() doesn't consume self (it's &self), so we still have self
        // Let me fix this logic:

        // Since get_tree() borrows self, we can still use self for graft
        self.graft_tree(new_tree)
    }

    /// Does not call isl_schedule_node_free() on being dropped. (For internal
    /// use only.)
    pub fn do_not_free_on_drop(&mut self) {
        self.should_free_on_drop = false;
    }
}

impl Drop for ScheduleNode {
    fn drop(&mut self) {
        if self.should_free_on_drop {
            unsafe {
                isl_schedule_node_free(self.ptr);
            }
        }
    }
}
